package cmd

import (
	"encoding/json"
	"fmt"
	"os"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"

	"github.com/vulsio/windows-vuln-feed/pkg/vulnerability/fetcher/bulletin"
	"github.com/vulsio/windows-vuln-feed/pkg/vulnerability/fetcher/cvrf"
)

// FetchVulerabilityCmd ...
var FetchVulerabilityCmd = &cobra.Command{
	Use:   "vulnerability",
	Short: "Fetch Microsoft Vulnerability Feed",
	Long:  "Fetch Microsoft Vulnerability Feed",
}

var fetchVulerabilityCVRFCmd = &cobra.Command{
	Use:     "cvrf",
	Short:   "Fetch Microsoft Vulnerability CVRF Feed",
	Long:    "Fetch Microsoft Vulnerability CVRF Feed",
	Example: "windows-vuln-feed fetch vulnerability cvrf",
	Args:    cobra.NoArgs,
	RunE: func(_ *cobra.Command, _ []string) error {
		cves, err := cvrf.FetchandParse()
		if err != nil {
			return errors.Wrap(err, "failed to fetch and parse")
		}
		if err := os.RemoveAll("./dist/vulnerability/cvrf"); err != nil {
			return errors.Wrap(err, "failed to remove vulnerability/cvrf")
		}
		if err := os.MkdirAll("./dist/vulnerability/cvrf", os.ModePerm); err != nil {
			return errors.Wrap(err, "failed to mkdir vulnerability/cvrf")
		}
		for _, cve := range cves {
			if err := func() error {
				f, err := os.Create(fmt.Sprintf("./dist/vulnerability/cvrf/%s.json", cve.CVEID))
				if err != nil {
					return errors.Wrapf(err, "failed to create vulnerability/cvrf/%s.json", cve.CVEID)
				}
				defer f.Close()
				if err := json.NewEncoder(f).Encode(cve); err != nil {
					return errors.Wrapf(err, "failed to encode vulnerability/cvrf/%s.json", cve.CVEID)
				}
				return nil
			}(); err != nil {
				return errors.WithStack(err)
			}
		}
		return nil
	},
}

var fetchVulerabilityBulletinCmd = &cobra.Command{
	Use:     "bulletin",
	Short:   "Fetch Microsoft Vulnerability Bulletin Feed",
	Long:    "Fetch Microsoft Vulnerability Bulletin Feed",
	Example: "windows-vuln-feed fetch vulnerability bulletin",
	Args:    cobra.NoArgs,
	RunE: func(_ *cobra.Command, _ []string) error {
		cves, err := bulletin.FetchandParse()
		if err != nil {
			return errors.Wrap(err, "failed to fetch and parse")
		}
		if err := os.RemoveAll("./dist/vulnerability/bulletin"); err != nil {
			return errors.Wrap(err, "failed to remove vulnerability/bulletin")
		}
		if err := os.MkdirAll("./dist/vulnerability/bulletin", os.ModePerm); err != nil {
			return errors.Wrap(err, "failed to mkdir vulnerability/bulletin")
		}
		for _, cve := range cves {
			if err := func() error {
				f, err := os.Create(fmt.Sprintf("./dist/vulnerability/bulletin/%s.json", cve.CVEID))
				if err != nil {
					return errors.Wrapf(err, "failed to create vulnerability/bulletin/%s.json", cve.CVEID)
				}
				defer f.Close()
				if err := json.NewEncoder(f).Encode(cve); err != nil {
					return errors.Wrapf(err, "failed to encode vulnerability/bulletin/%s.json", cve.CVEID)
				}
				return nil
			}(); err != nil {
				return errors.WithStack(err)
			}
		}
		return nil
	},
}

func init() {
	FetchVulerabilityCmd.AddCommand(fetchVulerabilityCVRFCmd, fetchVulerabilityBulletinCmd)
}
