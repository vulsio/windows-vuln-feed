package cvrf

import (
	"encoding/json"
	"encoding/xml"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/pkg/errors"
	"golang.org/x/exp/maps"

	"github.com/vulsio/windows-vuln-feed/pkg/vulnerability/model"
	winkb "github.com/vulsio/windows-vuln-feed/pkg/windows/kb"
	winpro "github.com/vulsio/windows-vuln-feed/pkg/windows/product"
)

const (
	updateListURL    = "https://api.msrc.microsoft.com/cvrf/v3.0/updates"
	cveURLFormat     = "https://msrc.microsoft.com/update-guide/vulnerability/%s"
	articleURLFormat = "https://support.microsoft.com/help/%s"
)

// FetchandParse ...
func FetchandParse() ([]model.Vulnerability, error) {
	log.Printf("INFO: fetch CVRF Updates. URL: %s", updateListURL)
	cvrfURLs, err := fetchCVRFURLs()
	if err != nil {
		return nil, errors.Wrap(err, "failed to fetch CVRF URLs from updates")
	}

	cves := []model.Vulnerability{}
	for _, cvrfURL := range cvrfURLs {
		log.Printf("INFO: fetch CVRF. URL: %s", cvrfURL)
		root, err := fetchCVRF(cvrfURL)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to fetch CVRF. url: %s", cvrfURL)
		}
		cs, err := Parse(root)
		if err != nil {
			return nil, errors.Wrapf(err, "failed to parse CVRF. url: %s", cvrfURL)
		}
		log.Printf("INFO: %d CVEs found from %s", len(cs), cvrfURL)
		cves = append(cves, cs...)
	}
	log.Printf("INFO: %d CVEs found", len(cves))

	return cves, nil
}

func fetchCVRFURLs() ([]string, error) {
	req, err := http.NewRequest(http.MethodGet, updateListURL, nil)
	if err != nil {
		return nil, errors.Wrap(err, "failed to build request")
	}
	req.Header.Set("Accept", "application/json")

	client := new(http.Client)
	resp, err := client.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "failed to do request")
	}
	defer resp.Body.Close()

	var us updates
	if err := json.NewDecoder(resp.Body).Decode(&us); err != nil {
		return nil, errors.Wrap(err, "failed to decode json")
	}

	urls := []string{}
	for _, u := range us.Value {
		uu, err := url.Parse(u.CvrfURL)
		if err != nil {
			return nil, errors.Wrap(err, "failed to parse url")
		}
		if path.Base(uu.Path) == "document" {
			continue
		}
		urls = append(urls, u.CvrfURL)
	}

	return urls, nil
}

func fetchCVRF(cvrfURL string) (Doc, error) {
	req, err := http.NewRequest(http.MethodGet, cvrfURL, nil)
	if err != nil {
		return Doc{}, errors.Wrap(err, "failed to build request")
	}
	req.Header.Set("Accept", "application/xml")

	client := new(http.Client)
	resp, err := client.Do(req)
	if err != nil {
		return Doc{}, errors.Wrap(err, "failed to do request")
	}
	defer resp.Body.Close()

	var root Doc
	if err := xml.NewDecoder(resp.Body).Decode(&root); err != nil {
		return Doc{}, errors.Wrap(err, "failed to decode xml")
	}

	return root, nil
}

// Parse ...
func Parse(root Doc) ([]model.Vulnerability, error) {
	cves, err := parseVulnerability(root.Vulnerability, parseProductTree(root.ProductTree))
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse vulnerability")
	}
	return cves, nil
}

func parseProductTree(ptree productTree) map[string]string {
	products := map[string]string{}
	for _, p := range ptree.FullProductName {
		products[p.ProductID] = winpro.Format(p.Text)
	}
	return products
}

func parseVulnerability(vulns []vulnerability, ptree map[string]string) ([]model.Vulnerability, error) {
	cves := []model.Vulnerability{}

	for _, vuln := range vulns {
		cve := model.Vulnerability{
			CVEID: vuln.CVE,
			Title: vuln.Title,
			URL:   fmt.Sprintf(cveURLFormat, vuln.CVE),
		}

		for _, note := range vuln.Notes.Note {
			switch note.Type {
			case "Description":
				if cve.Description != "" {
					log.Printf("WARN: %s Note Description: appears multiple times", vuln.CVE)
					break
				}
				cve.Description = strings.TrimSpace(note.Text)
			case "FAQ":
				cve.FAQs = append(cve.FAQs, strings.TrimSpace(note.Text))
			case "Tag":
				if cve.Tag != "" {
					log.Printf("WARN: %s Note Tag: appears multiple times", vuln.CVE)
					break
				}
				cve.Tag = note.Text
			case "CNA":
				if cve.CNA != "" {
					log.Printf("WARN: %s Note CNA: appears multiple times", vuln.CVE)
					break
				}
				cve.CNA = note.Text
			case "Other":
				if note.Title != "NIST NVD Details" {
					log.Printf("WARN: %s Note Other Title %s: is not the title assumed.", vuln.CVE, note.Title)
				}
			default:
				log.Printf("WARN: %s Note %s: is not the type assumed.", vuln.CVE, note.Type)
			}
		}

		products := map[string]model.Product{}
		for _, productID := range vuln.ProductStatuses.Status.ProductID {
			name, ok := ptree[productID]
			if !ok {
				return nil, errors.Errorf("failed to find product info for productID: %s", productID)
			}

			products[productID] = model.Product{
				ProductID: productID,
				Name:      name,
			}
		}

		for _, threat := range vuln.Threats.Threat {
			switch threat.Type {
			case "Impact":
				p, ok := products[threat.ProductID]
				if !ok {
					log.Printf("WARN: %s Threat Impact: ProductID:%s not found", vuln.CVE, threat.ProductID)
					break
				}
				p.Impact = threat.Description
				products[threat.ProductID] = p
			case "Severity":
				p, ok := products[threat.ProductID]
				if !ok {
					log.Printf("WARN: %s Threat Severity: ProductID:%s not found", vuln.CVE, threat.ProductID)
					break
				}
				p.Severity = threat.Description
				products[threat.ProductID] = p
			case "Exploit Status":
				if cve.ExploitStatus != "" {
					log.Printf("WARN: %s Threat Exploit Status: appears multiple times", vuln.CVE)
					break
				}
				cve.ExploitStatus = threat.Description
			default:
				log.Printf("WARN: %s Threat %s: is not the type assumed.", vuln.CVE, threat.Type)
			}
		}

		for _, scoreset := range vuln.CVSSScoreSets.ScoreSet {
			p, ok := products[scoreset.ProductID]
			if !ok {
				log.Printf("WARN: %s ScoreSet: ProductID:%s not found", vuln.CVE, scoreset.ProductID)
				continue
			}
			p.ScoreSet = &model.ScoreSet{
				BaseScore:     scoreset.BaseScore,
				TemporalScore: scoreset.TemporalScore,
				Vector:        scoreset.Vector,
			}
			products[scoreset.ProductID] = p
		}

		vendorFixKBs := map[string]map[string]model.KB{}
		knownIssueKBs := map[string]map[string]model.KB{}
		for _, remediation := range vuln.Remediations.Remediation {
			switch remediation.Type {
			case "Vendor Fix":
				var articleURL string
				if winkb.KBIDPattern.MatchString(remediation.Description) {
					articleURL = fmt.Sprintf(articleURLFormat, remediation.Description)
				}

				for _, productID := range remediation.ProductID {
					p, ok := products[productID]
					if !ok {
						log.Printf("WARN: %s Remediation Vendor Fix: ProductID: %s not found", vuln.CVE, productID)
						break
					}
					if _, ok := vendorFixKBs[productID]; !ok {
						vendorFixKBs[productID] = map[string]model.KB{}
					}

					if p.Name == "Microsoft Edge (Chromium-based)" && remediation.FixedBuild == "96.0 1954.29" {
						remediation.FixedBuild = "96.0.1954.29"
					}

					kb := model.KB{
						Article:         remediation.Description,
						RestartRequired: remediation.RestartRequired,
						SubType:         remediation.SubType,
						FixedBuild:      remediation.FixedBuild,
						ArticleURL:      articleURL,
						DownloadURL:     remediation.URL,
					}
					if knownIssueKB, ok := knownIssueKBs[productID][remediation.Description]; ok {
						kb.ArticleURL = knownIssueKB.ArticleURL
					}
					vendorFixKBs[productID][remediation.Description] = kb
				}
			case "Known Issue":
				for _, productID := range remediation.ProductID {
					if _, ok := products[productID]; !ok {
						log.Printf("WARN: %s Remediation Known Issue: ProductID: %s not found", vuln.CVE, productID)
						break
					}
					if _, ok := knownIssueKBs[productID]; !ok {
						knownIssueKBs[productID] = map[string]model.KB{}
					}
					kb := model.KB{
						Article:    remediation.Description,
						ArticleURL: remediation.URL,
					}
					if vendorFixKB, ok := vendorFixKBs[productID][remediation.Description]; ok {
						vendorFixKB.ArticleURL = kb.ArticleURL
						vendorFixKBs[productID][remediation.Description] = vendorFixKB
					}
					knownIssueKBs[productID][remediation.Description] = kb
				}
			case "Mitigation":
				if cve.Mitigation != "" {
					log.Printf("WARN: %s Remediation Mitigation: appears multiple times", vuln.CVE)
					break
				}
				cve.Mitigation = remediation.Description
			case "Workaround":
				if cve.Workaround != "" {
					log.Printf("WARN: %s Remediation Workaround: appears multiple times", vuln.CVE)
					break
				}
				cve.Workaround = remediation.Description
			default:
				log.Printf("WARN: %s Remediation %s: is not the type assumed.", vuln.CVE, remediation.Type)
			}
		}
		for productID, kbMap := range vendorFixKBs {
			p := products[productID]
			p.KBs = maps.Values(kbMap)
			products[productID] = p
		}

		for _, acknowledgment := range vuln.Acknowledgments.Acknowledgment {
			if acknowledgment.Name == "" && acknowledgment.URL == "" {
				continue
			}
			cve.Acknowledgments = append(cve.Acknowledgments, model.Acknowledgment{
				Name: acknowledgment.Name,
				URL:  acknowledgment.URL,
			})
		}

		for _, revision := range vuln.RevisionHistory.Revision {
			cve.Revisions = append(cve.Revisions, model.Revision{
				Number:      revision.Number,
				Date:        revision.Date,
				Description: strings.TrimSpace(revision.Description),
			})
		}

		cve.Products = append(cve.Products, maps.Values(products)...)

		cves = append(cves, cve)
	}

	return cves, nil
}
